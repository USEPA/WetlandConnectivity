---
title: "Wetland Connectivity Processing Steps"
author: "Marc Weber"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    theme: yeti
    highlighted: default 
    toc: yes
---

The following steps lay out the approach to generate wetland flow paths and calculate wetland hydrological connectivity at a national level

### Derive NLCD 2011 based wetlands
1. Extract wetland cells from NLCD 2011 raster
2. Use Arc region group tool to define contiguous wetland cells and assign a unique ID
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}
# Import arcpy module
import arcpy
import os
from arcpy.sa import *
arcpy.CheckOutExtension("Spatial")
from arcpy import env

# Set variables
working_dir = "J:/GitProjects/Wetland Connectivity/SpatialData"
nlcd = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/StreamCat/LandscapeRasters/QAComplete/nlcd2006.tif'

# Derive NLCD based wetlands
NLCD = Raster(nlcd)
wetlands = Con((NLCD == 90) | (NLCD == 95), 1,)
if not arcpy.Exists(working_dir + "/Wetlands" + ".tif"):
    wetlands.save(working_dir + "/Wetlands.tif")

# Now create unique wetland groups of contiguous wetland cells
Wetlands = Raster(working_dir + "/Wetlands.tif")
WetlandRegions = RegionGroup(Wetlands, "EIGHT", "WITHIN", "NO_LINK", "")
if not arcpy.Exists(working_dir + "/WetlandsRgnGrp.tif"):
    WetlandRegions.save(working_dir + "/WetlandsRgnGrp.tif")   
```

### Use Full Streams to test if wetlands are isolated from stream network
1. Build VAT for wetland raster
2. Set non-null values in fdrnull raster = 1
3. Multiply rasters and build VAT of output of (2)
4. Compare counts of regions in VATS 
5. Save isolated wetlands
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}


import arcpy
import os
from arcpy.sa import *
from arcpy import env
arcpy.CheckOutExtension("spatial")
from collections import deque, defaultdict
import pysal as ps
import pandas as pd
import numpy as np
import numpy.ma as ma
from osgeo import gdal
import osr

arcpy.env.overwriteOutput = True

def array2raster(newRasterfn,rasterfn,array):
    geotransform = rasterfn.GetGeoTransform()
    originX = geotransform[0]
    originY = geotransform[3]
    pixelWidth = geotransform[1]
    pixelHeight = geotransform[5]
    cols = array.shape[1]
    rows = array.shape[0]
    driver = gdal.GetDriverByName('GTiff')
    outRaster = driver.Create(newRasterfn, cols, rows, 1, gdal.GDT_Byte)
    outRaster.SetGeoTransform((originX, pixelWidth, 0, originY, 0, pixelHeight))
    outband = outRaster.GetRasterBand(1)
    outband.WriteArray(array)
    outRasterSRS = osr.SpatialReference()
    outRasterSRS.ImportFromWkt(rasterfn.GetProjectionRef())
    outRaster.SetProjection(outRasterSRS.ExportToWkt())
    outband.FlushCache()

def dbf2DF(dbfile, upper=True):
    db = ps.open(dbfile)
    cols = {col: db.by_col(col) for col in db.header}
    db.close()  #Close dbf 
    pandasDF = pd.DataFrame(cols)
    if upper == True:
        pandasDF.columns = pandasDF.columns.str.upper()              
    return pandasDF

nhddir = 'L:/Priv/CORFiles/Geospatial_Library/Data/RESOURCE/PHYSICAL/HYDROLOGY/NHDPlusV21'
#working_dir = 'J:/GitProjects/Wetland Connectivity/SpatialData'
working_dir = 'D:/WorkFolder/WetConnect_Aug2016'
wetlands_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands'
wetrpu_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands_rpu'
watermask_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/StreamCat/LandscapeRasters/QAComplete/WaterMask'
isolated_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/IsolatedWetlands'

arcpy.env.workspace = working_dir + '/ESRI_garbage'

inputs = {'CA':['18'],'CO':['14','15'],'GB':['16'],'GL':['04'],'MA':['02'],'MS':['05','06','07','08','10L','10U','11'],
          'NE':['01'],'PN':['17'],'RG':['13'],'SA':['03N','03S','03W'],'SR':['09'],'TX':['12']}
          
for region in inputs.keys():
    for hydro in inputs[region]:
        print 'on region ' + region + ' and hydro number ' + hydro
        for dirs in os.listdir(nhddir + "/NHDPlus%s/NHDPlus%s"%(region, hydro)):
            if dirs.count("FdrFac") and not dirs.count('.txt') and not dirs.count('.7z'):
                rpu =  dirs[-3:]
                
                startTime = time.time()  
                fdr = Raster(nhddir +"/NHDPlus" +region + "/NHDPlus" + hydro + "/NHDPlusFdrFac"  + rpu + "/fdr")
                    # Set env                
                arcpy.env.snapRaster = fdr
                arcpy.env.cellSize = "30"
                arcpy.env.mask = fdr
                arcpy.env.extent = fdr
                    # Get full streams              
                fullstreams = Raster(watermask_dir +"/FullStreams"  + rpu + ".tif")
                stream_exand = Expand(fullstreams, 1, 1) #Expand by 1 pixel to find wetlands that are disconnect by at least 1 pixel                
                streamcon = Con(IsNull(stream_exand), 1, 0) #Set null pixels to zero, else stay the same
                wetland_all = Raster(wetlands_dir + '/Wetlands_' + hydro + '.tif')
                    # Make wetland for each RPU                
                wetland_rpu = ExtractByMask(wetland_all, fdr)
                outWet_rpu = wetrpu_dir + '/Wetlands_' + rpu + '.tif'
                wetland_rpu.save(outWet_rpu) 
                arcpy.BuildRasterAttributeTable_management(outWet_rpu, "Overwrite")
                wetland = Raster(outWet_rpu)
                wetcon = Con(IsNull(wetland),0, wetland)
                    # Multiply to create temporary query wetland
                tmpWet = streamcon * wetcon
                tmpWet.save(working_dir + '/ScratchDir/queryWetland_' + rpu + '.tif')
                arcpy.BuildRasterAttributeTable_management(working_dir + '/ScratchDir/queryWetland_' + rpu + '.tif', "Overwrite")
                    # Read in and merge VATs to compare 
                lesswet = dbf2DF(working_dir + '/ScratchDir/queryWetland_' + rpu + '.tif.vat.dbf')
                allwet = dbf2DF(outWet_rpu + '.vat.dbf')
                new = pd.merge(allwet, lesswet, on = 'VALUE', how = 'left')                
                isolated = new.loc[new['COUNT_x'] == new['COUNT_y']]
                isolated = np.array(isolated.VALUE).astype(int)
                    # Read in wetland raster, convert to numpy array, flatten, and query against list of isolated wetlands
                wetland_ras = gdal.Open(outWet_rpu)
                wetland_arr = np.array(wetland_ras.GetRasterBand(1).ReadAsArray())                
                wetshape = wetland_arr.shape                               
                wetland_flat = wetland_arr.flatten() #Flatten 2d array to 1d
                z = np.where(np.in1d(wetland_flat, isolated), 1, np.NaN)
                z.shape = wetshape             
                    # Stuff to get it out to TIF ESRI can see
                newraster = array2raster(working_dir + '/ScratchDir/isoWetTmp_' + rpu + '.tif', wetland_ras, z)
                newRaster = Raster(working_dir + '/ScratchDir/isoWetTmp_' + rpu + '.tif')
                newRaster2 = Times(wetland_rpu, newRaster) #run it through a process to get it to be integer and in native ESRI format (exclude odd NUMPY stuff)    
                newRaster3 = Con(newRaster2 != 0, newRaster2)
                newRaster3.save(isolated_dir + '/isoWetlands_' + rpu + '.tif')              
                print "Minutes for this region: " + str((time.time()-startTime) / 60.0)
                            

```


### Generate wetland points for each wetland group
1. Generate points for each raster cell in wetland groups
2. Use geopandas to select just the point in each group with largest flow accumulation (the wetland outlet)
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}
import arcpy
import os
from arcpy.sa import *
arcpy.CheckOutExtension("Spatial")
from arcpy import env
import geopandas as gp
import pandas as pd
from datetime import datetime

nhddir = "L:/Priv/CORFiles/Geospatial_Library/Data/RESOURCE/PHYSICAL/HYDROLOGY/NHDPlusV21"
working_dir = 'J:/GitProjects/Wetland Connectivity/SpatialData'
wetlands_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands'
watermask_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/StreamCat/LandscapeRasters/QAComplete/WaterMask'

inputs = {'CA':['18'],'CO':['14','15'],'GB':['16'],'GL':['04'],'MA':['02'],'MS':['05','06','07','08','10L','10U','11'],
          'NE':['01'],'PN':['17'],'RG':['13'],'SA':['03N','03S','03W'],'SR':['09'],'TX':['12']}

for region in inputs.keys():
    for hydro in inputs[region]:
        print 'on region ' + region + ' and hydro number ' + hydro
        for dirs in os.listdir(nhddir + "/NHDPlus%s/NHDPlus%s"%(region, hydro)):
            if dirs.count("FdrFac") and not dirs.count('.txt') and not dirs.count('.7z'):
                print dirs[-3:]
                # Execute ExtractValuesToPoints to get flow accumulation for each wetland region grid point
                fac = nhddir +"/NHDPlus" +region + "/NHDPlus" + hydro + "/NHDPlusFdrFac"  + dirs[-3:] + "/fac"
                
                # Raster to points
                outPoint = working_dir + "/ScratchDir/RasterPoints" + dirs[-3:] + ".shp"
                # Execute RasterToPoint
                WetlandRegions = working_dir + "/Wetlands" + dirs[-3:] + ".tif"
                if not arcpy.Exists(outPoint):
                    arcpy.RasterToPoint_conversion(WetlandRegions, outPoint, "VALUE")
                
                outPointFac = working_dir + "/ScratchDir/PointFac" + dirs[-3:] +  ".shp"
                if not arcpy.Exists(outPointFac):
                    ExtractValuesToPoints(outPoint, fac, outPointFac,"", "ALL")
                
                # Process: Make Feature Layer
                arcpy.MakeFeatureLayer_management(outPointFac, "FacPoints")
                
                # Process: Make Feature Layer
                BoundaryUnits = nhddir + "/NHDPlusGlobalData/BoundaryUnit.shp"
                arcpy.MakeFeatureLayer_management(BoundaryUnits, "BoundaryUnit", "\"UnitID\" = '%s'"%(dirs[-3:]))
                
                # Process: Select Layer By Location
                arcpy.SelectLayerByLocation_management("FacPoints", "INTERSECT", "BoundaryUnit", "", "NEW_SELECTION")
                
                # Process: Feature Class To Shapefile (multiple)
                arcpy.FeatureClassToShapefile_conversion("FacPoints", working_dir + "/ScratchDir")
                
                # Use Pandas to get the minimum flow distance point for each wetland region group ID
                WetPoints = gp.GeoDataFrame.from_file(working_dir + "/ScratchDir/FacPoints.shp")
                # First we'll drop all the -999 sites - these are wetland grid cells in the stream
                WetPoints = WetPoints.loc[WetPoints.RASTERVALU!=-9999]
                # Now we'll group points by wetland region group maximum flow accumulation
                WetPoints = WetPoints.loc[WetPoints.groupby("GRID_CODE")["RASTERVALU"].idxmax()]
                # And then we'll export to a text file after grabbing coordinates as fields we add
                df = WetPoints.drop('geometry', axis=1)  # df is a DataFrame, not GeoDataFrame after the drop
                def getXY(pt):
                    return (pt.x, pt.y)
                centroidseries = WetPoints['geometry'].centroid
                x,y = [list(t) for t in zip(*map(getXY, centroidseries))]
                WetPoints['XCOORD'] = x
                WetPoints['YCOORD'] = y
                if not arcpy.Exists(working_dir + "/WetlandPoints" + dirs[-3:] +".shp"):
                    WetPoints.to_file(working_dir + "/WetlandPoints" + dirs[-3:]+ ".shp", driver = 'ESRI Shapefile')  
                df['XCOORD'] = x
                df['YCOORD'] = y
                df.head()
                #df[x] = WetPoints.geometry.apply(lambda p: p.x)
                #df[y] = WetPoints.geometry.apply(lambda p: p.y)
                df.to_csv(working_dir +"/WetlandPoints" + dirs[-3:] + ".csv")
                  
                df = pd.read_csv(working_dir +"/WetlandPoints" + dirs[-3:] + ".csv") 
                        
                WetPoints = working_dir + "/WetlandPoints" + dirs[-3:] + ".shp"   
                arcpy.Delete_management(outPoint)
                arcpy.Delete_management(outPointFac)
                arcpy.Delete_management("FacPoints")
                arcpy.Delete_management(working_dir + "/ScratchDir/FacPoints.shp")    
```  

### Generate Cost Paths from each wetland outlet point to NHDPlus stream lines
1. Create a full streams null grid to use in cost path analysis
2. Run cost path tool using wetland outlet points, NHDPlus hydro DEM, and full streams null grid
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}
import arcpy
import os
from arcpy.sa import *
arcpy.CheckOutExtension("Spatial")
from arcpy import env
from datetime import datetime

nhddir = "L:/Priv/CORFiles/Geospatial_Library/Data/RESOURCE/PHYSICAL/HYDROLOGY/NHDPlusV21"
working_dir = 'J:/GitProjects/Wetland Connectivity/SpatialData'
wetlands_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands'
watermask_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/StreamCat/LandscapeRasters/QAComplete/WaterMask'

inputs = {'CA':['18'],'CO':['14','15'],'GB':['16'],'GL':['04'],'MA':['02'],'MS':['05','06','07','08','10L','10U','11'],
          'NE':['01'],'PN':['17'],'RG':['13'],'SA':['03N','03S','03W'],'SR':['09'],'TX':['12']}

for region in inputs.keys():
    for hydro in inputs[region]:
        print 'on region ' + region + ' and hydro number ' + hydro
        for dirs in os.listdir(nhddir + "/NHDPlus%s/NHDPlus%s"%(region, hydro)):
            if dirs.count("FdrFac") and not dirs.count('.txt') and not dirs.count('.7z'):
                print dirs[-3:]
                
                # Create Full cost path raster - first, we'll geneerate a fullstreamsnull grid to pass to cost path tool
                outfdr1 = Con(IsNull(FullStreams),0, 99)
                outfdr2 = Con(outfdr1<>99, fdr,)
                if not arcpy.Exists(working_dir + "/FullStreamsFDRNull" + dirs[-3:] + ".tif"):
                    outfdr2.save(working_dir + "/FullStreamsFDRNull" + dirs[-3:] + ".tif")
                fullstreamsnull = working_dir + "/FullStreamsFDRNull" + dirs[-3:] + ".tif"
                if not arcpy.Exists(working_dir + "/ScratchDir/CostPath" + dirs[-3] + ".tif"):
                    arcpy.gp.CostPath_sa(WetPoints, nhddir + "/NHDPlus" + region + "/NHDPlus" + hydro + "/NHDPlusHydrodem" + dirs[-3:] + "/hydrodem", 
                                             fullstreamsnull, working_dir + "/ScratchDir/CostPath" + dirs[-3] + ".tif", "EACH_CELL", "GRID_CODE")
```

### Modify cost paths to associate paths with wetland regioin groups
1. Run stream link on cost path rasters
2. Split lines at wetland points to generate unique IDs
3. Create template raster and run euclideans allocation to get flow paths to match NHPlus fdr rasters
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}
import arcpy
import os
from arcpy.sa import *
arcpy.CheckOutExtension("Spatial")
from arcpy import env
from datetime import datetime

nhddir = "L:/Priv/CORFiles/Geospatial_Library/Data/RESOURCE/PHYSICAL/HYDROLOGY/NHDPlusV21"
working_dir = 'J:/GitProjects/Wetland Connectivity/SpatialData'
wetlands_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands'
watermask_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/StreamCat/LandscapeRasters/QAComplete/WaterMask'

inputs = {'CA':['18'],'CO':['14','15'],'GB':['16'],'GL':['04'],'MA':['02'],'MS':['05','06','07','08','10L','10U','11'],
          'NE':['01'],'PN':['17'],'RG':['13'],'SA':['03N','03S','03W'],'SR':['09'],'TX':['12']}

for region in inputs.keys():
    for hydro in inputs[region]:
        print 'on region ' + region + ' and hydro number ' + hydro
        for dirs in os.listdir(nhddir + "/NHDPlus%s/NHDPlus%s"%(region, hydro)):
            if dirs.count("FdrFac") and not dirs.count('.txt') and not dirs.count('.7z'):
                print dirs[-3:]
                
                # Read in cost path rasters
                outCostPath = Raster(working_dir + "/ScratchDir/CostPath" + dirs[-3] + ".tif")
                outCostPath = Con(outCostPath <> 0, outCostPath,)

                # Run stream link on the cost path to 'uniqueify' the sections
                # Execute StreamLink
                outStreamLink = StreamLink(outCostPath, fdr)
                # Save the output 
                outStreamLink.save(working_dir + "/ScratchDir/StreamLink" + dirs[-3] + ".tif")
                
                # Raster to polyline to get splits along path excatly right
                arcpy.RasterToPolyline_conversion(in_raster=working_dir + "/ScratchDir/StreamLink" + dirs[-3] + ".tif", out_polyline_features=working_dir + "/ScratchDir/StreamLink" + dirs[-3] + ".shp", background_value="NODATA", minimum_dangle_length="0", simplify="NO_SIMPLIFY", raster_field="VALUE")
                
                # Split the polylines at wetland points
                arcpy.SplitLineAtPoint_management(in_features=working_dir + "/ScratchDir/StreamLink" + dirs[-3] + ".shp", point_features = working_dir + "/WetlandPoints" + dirs[-3:]+ ".shp", out_feature_class = working_dir + "/ScratchDir/StreamLinkSplit" + dirs[-3] + ".shp", search_radius="90 Meters")
                
                # Now convert polylines back to a raster
                arcpy.PolylineToRaster_conversion(in_features = working_dir + "/ScratchDir/StreamLinkSplit" + dirs[-3] + ".shp", value_field="OBJECTID", out_rasterdataset=temp + "/StreamLinkSplit.tif", cell_assignment="MAXIMUM_LENGTH", priority_field="NONE", cellsize="30")
                                   
                EucAlloc = EucAllocation(temp + "/StreamLinkSplit.tif", "30", "", "30", "Value", "", "")
                
                # Create dummy StreamLink with every value a 1
                PathTemplate = Raster(temp + "/StreamLink.tif")
                PathTemplate = Con(PathTemplate> 0,1,)
#                    EucAlloc = Raster(temp + '/StreamLink_EucAlloc.tif')
                
                Adjusted = EucAlloc * PathTemplate
                
                Adjusted.save(working_dir + "/StreamLink" + dirs[-3:] + ".tif")  
                
                
```

### Sort out WetlandPathsConnect, WetlandCatsConnect, making final tables
Currently in several scripts that need to be organized here

### Issues to sort out
1. The connection between wetland IDs and wetland paths not totally working.
	a. The split in flow paths happens on the cell downstream of wetland pour points
	b. Because of this, paths that flow through more than one wetland are being assigned
	   to wrong wetland ID in places
	c. The fix is to use the From-To raster to update the wetland-streamlink lookup tables (L:\Priv\CORFiles\Geospatial_Library\Data\Project\WetlandConnectivity\LookupTables)
		i. Wherever there is more than one wetland point associated with a wetland ID in the wetland - streamlink lookup table, then:
			- create a table result of point / raster extracts of wetland points and the From-To .tif
			- If the result of the point extract is NA, keep the streamlink for the wetland in the wetland-streamlink table
			- If the results of the point extract is not NA, replace the streamlink for that wetland with the 'TO' streamlink
2. Slopes for 17b are lower than neighboring regions - why?
3. Need to connect wetland catchments to get full upslope watersheds for precip
4. Calculate geometric mean


### Delineate wetland watersheds
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}
# Import arcpy module
import arcpy
import os
from arcpy.sa import *
from datetime import datetime
import struct, decimal, itertools
import pysal as ps
import pandas as pd
import numpy as np
from collections import deque, defaultdict
# Check out any necessary licenses
arcpy.CheckOutExtension("spatial")

```











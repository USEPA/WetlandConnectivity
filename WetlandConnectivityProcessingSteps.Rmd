---
title: "Wetland Connectivity Processing Steps"
author: "Marc Weber & Ryan Hill"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    theme: yeti
    highlighted: default 
    toc: yes
---

The following steps lay out the approach to generate wetland flow paths and calculate wetland hydrological connectivity at a national level

## Wetland extraction and preparation

### Derive NLCD 2011 based wetlands
1. Extract wetland cells from NLCD 2011 raster
2. Use Arc region group tool to define contiguous wetland cells and assign a unique ID
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}
# Import arcpy module
import arcpy
import os
from arcpy.sa import *
arcpy.CheckOutExtension("Spatial")
from arcpy import env

# Set variables
working_dir = "J:/GitProjects/Wetland Connectivity/SpatialData"
nlcd = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/StreamCat/LandscapeRasters/QAComplete/nlcd2006.tif'

# Derive NLCD based wetlands
NLCD = Raster(nlcd)
wetlands = Con((NLCD == 90) | (NLCD == 95), 1,)
if not arcpy.Exists(working_dir + "/Wetlands" + ".tif"):
    wetlands.save(working_dir + "/Wetlands.tif")

# Now create unique wetland groups of contiguous wetland cells
Wetlands = Raster(working_dir + "/Wetlands.tif")
WetlandRegions = RegionGroup(Wetlands, "EIGHT", "WITHIN", "NO_LINK", "")
if not arcpy.Exists(working_dir + "/WetlandsRgnGrp.tif"):
    WetlandRegions.save(working_dir + "/WetlandsRgnGrp.tif")   
```

### Use Full Streams to test if wetlands are isolated from stream network
1. Build VAT for wetland raster
2. Set non-null values in fdrnull raster = 1
3. Multiply rasters and build VAT of output of (2)
4. Compare counts of regions in VATS 
5. Save isolated wetlands
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}

import arcpy
import os
from arcpy.sa import *
from arcpy import env
arcpy.CheckOutExtension("spatial")
from collections import deque, defaultdict
import pysal as ps
import pandas as pd
import numpy as np
import numpy.ma as ma
from osgeo import gdal
import osr

arcpy.env.overwriteOutput = True

def array2raster(newRasterfn,rasterfn,array):
    geotransform = rasterfn.GetGeoTransform()
    originX = geotransform[0]
    originY = geotransform[3]
    pixelWidth = geotransform[1]
    pixelHeight = geotransform[5]
    cols = array.shape[1]
    rows = array.shape[0]

    driver = gdal.GetDriverByName('GTiff')
    outRaster = driver.Create(newRasterfn, cols, rows, 1, gdal.GDT_Byte)
    outRaster.SetGeoTransform((originX, pixelWidth, 0, originY, 0, pixelHeight))
    outband = outRaster.GetRasterBand(1)
    outband.WriteArray(array)
    outRasterSRS = osr.SpatialReference()
    outRasterSRS.ImportFromWkt(rasterfn.GetProjectionRef())
    outRaster.SetProjection(outRasterSRS.ExportToWkt())
    outband.FlushCache()

def dbf2DF(dbfile, upper=True):
    db = ps.open(dbfile)
    cols = {col: db.by_col(col) for col in db.header}
    db.close()  #Close dbf 
    pandasDF = pd.DataFrame(cols)
    if upper == True:
        pandasDF.columns = pandasDF.columns.str.upper()              
    return pandasDF


nhddir = 'L:/Priv/CORFiles/Geospatial_Library/Data/RESOURCE/PHYSICAL/HYDROLOGY/NHDPlusV21'
working_dir = 'J:/GitProjects/Wetland Connectivity/SpatialData'
#working_dir = 'D:/WorkFolder/WetConnect_Aug2016'
wetlands_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands'
wetrpu_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands_rpu'
watermask_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/StreamCat/LandscapeRasters/QAComplete/WaterMask'
isolated_dir = 'J:/GitProjects/Wetland Connectivity/SpatialData/IsolatedWetlands'

arcpy.env.workspace = working_dir + '/garbage3'

#inputs = {'CA':['18'],'CO':['14','15'],'GB':['16'],'GL':['04'],'MA':['02'],'MS':['05','06','07','08','10L','10U','11'],
#          'NE':['01'],'PN':['17'],'RG':['13'],'SA':['03N','03S','03W'],'SR':['09'],'TX':['12']}
inputs = {'PN':['17'],'RG':['13'],'SA':['03N','03S','03W'],'SR':['09'],'TX':['12']}           

for region in inputs.keys():
    for hydro in inputs[region]:
        print 'Region ' + region + ' and hydro number ' + hydro
        for dirs in os.listdir(nhddir + "/NHDPlus%s/NHDPlus%s"%(region, hydro)):
            if dirs.count("FdrFac") and not dirs.count('.txt') and not dirs.count('.7z'):
                rpu =  dirs[-3:]

                if not os.path.exists(isolated_dir + '/isoWetlands_' + rpu + '.tif'):                     
                    print rpu
                        #-- thanks ESRI --
                    garbage = working_dir + '/ESRI_garbage/garbage_' + rpu
                    if not os.path.exists(garbage):
                        os.makedirs(garbage)
                    arcpy.env.workspace = garbage
                        #-- thanks ESRI --
                    startTime = time.time()  
                    fdr = Raster(nhddir +"/NHDPlus" +region + "/NHDPlus" + hydro + "/NHDPlusFdrFac"  + rpu + "/fdr")
                        # Set env                
                    arcpy.env.snapRaster = fdr
                    arcpy.env.cellSize = "30"
                    arcpy.env.mask = fdr
                    arcpy.env.extent = fdr
                    # Get full streams              
                    fullstreams = Raster(watermask_dir +"/FullStreams"  + rpu + ".tif")
                    stream_exand = Expand(fullstreams, 1, 1) #Expand by 1 pixel to find wetlands that are disconnect by at least 1 pixel                
                    streamcon = Con(IsNull(stream_exand), 1, 0) #Set null pixels to zero, else stay the same                             
                    wetland_all = Raster(wetlands_dir + '/Wetlands_' + hydro + '.tif')
                    outWet_rpu = wetrpu_dir + '/Wetlands_' + rpu + '.tif'
                    # Make wetland for each RPU 
                    if not arcpy.Exists(outWet_rpu):
                        wetland_rpu = ExtractByMask(wetland_all, fdr)
                        wetland_rpu.save(outWet_rpu) 
                    #arcpy.gp.ExtractByMask_sa(wetland_all, fdr, outWet_rpu)
                    arcpy.BuildRasterAttributeTable_management(outWet_rpu, "Overwrite")
                    wetland = Raster(outWet_rpu)
                    wetcon = Con(IsNull(wetland),0, wetland)
                    # Multiply to create temporary query wetland
                    tmpWet = streamcon * wetcon
                    if not arcpy.Exists(working_dir + '/ScratchDir/queryWetland_' + rpu + '.tif'):
                        tmpWet.save(working_dir + '/ScratchDir/queryWetland_' + rpu + '.tif')
                    arcpy.BuildRasterAttributeTable_management(working_dir + '/ScratchDir/queryWetland_' + rpu + '.tif', "Overwrite")
                        # Read in and merge VATs to compare 
                    lesswet = dbf2DF(working_dir + '/ScratchDir/queryWetland_' + rpu + '.tif.vat.dbf')
                    allwet = dbf2DF(outWet_rpu + '.vat.dbf')
                    new = pd.merge(allwet, lesswet, on = 'VALUE', how = 'left')                
                    isolated = new.loc[new['COUNT_x'] == new['COUNT_y']]
                    isolated = np.array(isolated.VALUE).astype(int)
                        # Read in wetland raster, convert to numpy array, flatten, and query against list of isolated wetlands
                    wetland_ras = gdal.Open(outWet_rpu)
                    wetland_arr = np.array(wetland_ras.GetRasterBand(1).ReadAsArray())                
                    wetshape = wetland_arr.shape                               
                    wetland_flat = wetland_arr.flatten() #Flatten 2d array to 1d
                    z = np.where(np.in1d(wetland_flat, isolated), 1, np.NaN)
                    z.shape = wetshape             
                        # Stuff to get it out to TIF ESRI can see
                    newraster = array2raster(working_dir + '/ScratchDir/isoWetTmp_' + rpu + '.tif', wetland_ras, z)
                    newRaster = Raster(working_dir + '/ScratchDir/isoWetTmp_' + rpu + '.tif')
                    newRaster2 = Times(wetland_rpu, newRaster) #run it through a process to get it to be integer and in native ESRI format (exclude odd NUMPY stuff)    
                    newRaster3 = Con(newRaster2 != 0, newRaster2)
                    newRaster3.save(isolated_dir + '/isoWetlands_' + rpu + '.tif')              
                    print "Minutes for this region: " + str((time.time()-startTime) / 60.0)                          

```


### Generate wetland points for each wetland group
1. Generate points for each raster cell in wetland groups
2. Use geopandas to select just the point in each group with largest flow accumulation (the wetland outlet)
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}
import arcpy
import os
from arcpy.sa import *
arcpy.CheckOutExtension("Spatial")
from arcpy import env
import geopandas as gp
import pandas as pd
from datetime import datetime

nhddir = "L:/Priv/CORFiles/Geospatial_Library/Data/RESOURCE/PHYSICAL/HYDROLOGY/NHDPlusV21"
working_dir = 'J:/GitProjects/Wetland Connectivity/SpatialData'
#working_dir = 'D:/WorkFolder/WetConnect_Aug2016'
wetlands_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands'
wetrpu_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands_rpu'
watermask_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/StreamCat/LandscapeRasters/QAComplete/WaterMask'
isolated_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/IsolatedWetlands'
wetpoints_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/WetlandPoints'

inputs = {'CA':['18'],'CO':['14','15'],'GB':['16'],'GL':['04'],'MA':['02'],'MS':['05','06','07','08','10L','10U','11'],
          'NE':['01'],'PN':['17'],'RG':['13'],'SA':['03N','03S','03W'],'SR':['09'],'TX':['12']}

for region in inputs.keys():
    for hydro in inputs[region]:
        print 'on region ' + region + ' and hydro number ' + hydro
        for dirs in os.listdir(nhddir + "/NHDPlus%s/NHDPlus%s"%(region, hydro)):
            if dirs.count("FdrFac") and not dirs.count('.txt') and not dirs.count('.7z'):
                if not arcpy.Exists(wetpoints_dir + "/WetlandPoints" + dirs[-3:]+ ".shp"):
                    print dirs[-3:]
                    # Execute ExtractValuesToPoints to get flow accumulation for each wetland region grid point
                    fac = nhddir +"/NHDPlus" +region + "/NHDPlus" + hydro + "/NHDPlusFdrFac"  + dirs[-3:] + "/fac"
                    arcpy.env.snapRaster = fac
                    arcpy.env.mask = fac
                    arcpy.env.extent = fac
                    # Raster to points
                    outPoint = working_dir + "/ScratchDir/RasterPoints" + dirs[-3:] + ".shp"
                    # Execute RasterToPoint
                    Wetlands = isolated_dir + "/isoWetlands_" + dirs[-3:] + ".tif"
                    if not arcpy.Exists(outPoint):
                        arcpy.RasterToPoint_conversion(Wetlands, outPoint, "VALUE")
                    
                    outPointFac = working_dir + "/ScratchDir/PointFac" + dirs[-3:] +  ".shp"
                    if not arcpy.Exists(outPointFac):
                        ExtractValuesToPoints(outPoint, fac, outPointFac,"", "ALL")
                    
                    # Process: Make Feature Layer
                    arcpy.MakeFeatureLayer_management(outPointFac, "FacPoints")
                    
                    # Process: Make Feature Layer
                    BoundaryUnits = nhddir + "/NHDPlusGlobalData/BoundaryUnit.shp"
                    arcpy.MakeFeatureLayer_management(BoundaryUnits, "BoundaryUnit", "\"UnitID\" = '%s'"%(dirs[-3:]))
                    
                    # Process: Select Layer By Location
                    arcpy.SelectLayerByLocation_management("FacPoints", "INTERSECT", "BoundaryUnit", "", "NEW_SELECTION")
                    
                    # Process: Feature Class To Shapefile (multiple)
                    arcpy.FeatureClassToShapefile_conversion("FacPoints", working_dir + "/ScratchDir")
                    
                    # Use Pandas to get the minimum flow distance point for each wetland region group ID
                    WetPoints = gp.GeoDataFrame.from_file(working_dir + "/ScratchDir/FacPoints.shp")
                    # First we'll drop all the -999 sites - these are wetland grid cells in the stream
                    WetPoints = WetPoints.loc[WetPoints.RASTERVALU!=-9999]
                    # Now we'll group points by wetland region group maximum flow accumulation
                    WetPoints = WetPoints.loc[WetPoints.groupby("GRID_CODE")["RASTERVALU"].idxmax()]
                    # And then we'll export to a text file after grabbing coordinates as fields we add
                    df = WetPoints.drop('geometry', axis=1)  # df is a DataFrame, not GeoDataFrame after the drop
                    def getXY(pt):
                        return (pt.x, pt.y)
                    centroidseries = WetPoints['geometry'].centroid
                    x,y = [list(t) for t in zip(*map(getXY, centroidseries))]
                    WetPoints['XCOORD'] = x
                    WetPoints['YCOORD'] = y
                    if not arcpy.Exists(wetpoints_dir + "/WetlandPoints" + dirs[-3:] +".shp"):
                        WetPoints.to_file(wetpoints_dir + "/WetlandPoints" + dirs[-3:]+ ".shp", driver = 'ESRI Shapefile')  
                    df['XCOORD'] = x
                    df['YCOORD'] = y
                    df.head()
                    #df[x] = WetPoints.geometry.apply(lambda p: p.x)
                    #df[y] = WetPoints.geometry.apply(lambda p: p.y)
                    df.to_csv(wetpoints_dir +"/WetlandPoints" + dirs[-3:] + ".csv")
                            
                    WetPoints = wetpoints_dir + "/WetlandPoints" + dirs[-3:] + ".shp"   
                    arcpy.Delete_management(outPoint)
                    arcpy.Delete_management(outPointFac)
                    arcpy.Delete_management("FacPoints")
                    arcpy.Delete_management(working_dir + "/ScratchDir/FacPoints.shp")   
```  

## Wetland path processes

### Generate Cost Paths from each wetland outlet point to NHDPlus stream lines
1. Create a full streams null grid to use in cost path analysis
2. Run cost path tool using wetland outlet points, NHDPlus hydro DEM, and full streams null grid
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}
import arcpy
import os
from arcpy.sa import *
arcpy.CheckOutExtension("Spatial")
from arcpy import env
from datetime import datetime

nhddir = 'L:/Priv/CORFiles/Geospatial_Library/Data/RESOURCE/PHYSICAL/HYDROLOGY/NHDPlusV21'
working_dir = 'J:/GitProjects/Wetland Connectivity/SpatialData'
#working_dir = 'D:/WorkFolder/WetConnect_Aug2016'
wetlands_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands'
wetrpu_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands_rpu'
watermask_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/StreamCat/LandscapeRasters/QAComplete/WaterMask'
isolated_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/IsolatedWetlands'
paths_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/WetlandPath'

#inputs = {'CA':['18'],'CO':['14','15'],'GB':['16'],'GL':['04'],'MA':['02'],'MS':['05','06','07','08','10L','10U','11'],
#          'NE':['01'],'PN':['17'],'RG':['13'],'SA':['03N','03S','03W'],'SR':['09'],'TX':['12']}

inputs = {'CO':['14','15']}
          
for region in inputs.keys():
    for hydro in inputs[region]:
        print 'on region ' + region + ' and hydro number ' + hydro
        for dirs in os.listdir(nhddir + "/NHDPlus%s/NHDPlus%s"%(region, hydro)):
            if dirs.count("FdrFac") and not dirs.count('.txt') and not dirs.count('.7z'):
                print dirs[-3:]
                rpu = dirs[-3:]
                fdr = Raster(nhddir +"/NHDPlus" +region + "/NHDPlus" + hydro + "/NHDPlusFdrFac"  + rpu + "/fdr")
                # Read in cost path rasters
                outCostPath = Raster(working_dir + "/CostPath" + rpu + ".tif")
                outCostPath = Con(outCostPath <> 0, outCostPath,)

                # Run stream link on the cost path to 'uniqueify' the sections
                # Execute StreamLink
                outStreamLink = StreamLink(outCostPath, fdr)
                # Save the output 
                outStreamLink.save(working_dir + "/ScratchDir/StreamLink" + rpu + ".tif")
                
                # Raster to polyline to get splits along path excatly right
                arcpy.RasterToPolyline_conversion(in_raster=working_dir + "/ScratchDir/StreamLink" + rpu + ".tif", out_polyline_features=working_dir + "/ScratchDir/StreamLink" + dirs[-3] + ".shp", background_value="NODATA", minimum_dangle_length="0", simplify="NO_SIMPLIFY", raster_field="VALUE")
                
                # Split the polylines at wetland points
                arcpy.SplitLineAtPoint_management(in_features=working_dir + "/ScratchDir/StreamLink" + rpu + ".shp", point_features = working_dir + "/WetlandPoints" + dirs[-3:]+ ".shp", out_feature_class = working_dir + "/ScratchDir/StreamLinkSplit" + dirs[-3] + ".shp", search_radius="90 Meters")
                
                # Now convert polylines back to a raster
                arcpy.PolylineToRaster_conversion(in_features = working_dir + "/ScratchDir/StreamLinkSplit" + rpu + ".shp", value_field="OBJECTID", out_rasterdataset=temp + "/StreamLinkSplit.tif", cell_assignment="MAXIMUM_LENGTH", priority_field="NONE", cellsize="30")
                                   
                EucAlloc = EucAllocation(temp + "/StreamLinkSplit.tif", "30", "", "30", "Value", "", "")
                
                # Create dummy StreamLink with every value a 1
                PathTemplate = Raster(temp + "/StreamLink.tif")
                PathTemplate = Con(PathTemplate> 0,1,)
#                    EucAlloc = Raster(temp + '/StreamLink_EucAlloc.tif')
                
                Adjusted = EucAlloc * PathTemplate
                
                Adjusted.save(working_dir + "/StreamLink" + rpu + ".tif")


```

### Modify cost paths to associate paths with wetlands
1. Run stream link on cost path rasters
2. Split lines at wetland points to generate unique IDs
3. Create template raster and run euclideans allocation to get flow paths to match NHPlus fdr rasters
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}
import arcpy
import os
from arcpy.sa import *
arcpy.CheckOutExtension("Spatial")
from arcpy import env
from datetime import datetime

nhddir = "L:/Priv/CORFiles/Geospatial_Library/Data/RESOURCE/PHYSICAL/HYDROLOGY/NHDPlusV21"
working_dir = 'F:/WetlandConnectivity/SpatialData'
wetlands_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/AllWetlands'
watermask_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/StreamCat/LandscapeRasters/QAComplete/WaterMask'

inputs = {'CA':['18'],'CO':['14','15'],'GB':['16'],'GL':['04'],'MA':['02'],'MS':['05','06','07','08','10L','10U','11'],
          'NE':['01'],'PN':['17'],'RG':['13'],'SA':['03N','03S','03W'],'SR':['09'],'TX':['12']}

for region in inputs.keys():
    for hydro in inputs[region]:
        print 'on region ' + region + ' and hydro number ' + hydro
        for dirs in os.listdir(nhddir + "/NHDPlus%s/NHDPlus%s"%(region, hydro)):
            if dirs.count("FdrFac") and not dirs.count('.txt') and not dirs.count('.7z'):
                print dirs[-3:]
                rpu = dirs[-3:]
                fdr = Raster(nhddir +"/NHDPlus" +region + "/NHDPlus" + hydro + "/NHDPlusFdrFac"  + rpu + "/fdr")
                arcpy.env.snapRaster = fdr
                arcpy.env.cellSize = "30"
                arcpy.env.mask = fdr
                arcpy.env.extent = fdr
                # Read in cost path rasters
                
                outCostPath = Raster(working_dir + "/CostPath" + rpu + ".tif")
                outCostPath = Con(outCostPath <> 0, outCostPath,)
                # Run stream link on the cost path to 'uniqueify' the sections
                # Execute StreamLink
                outStreamLink = StreamLink(outCostPath, fdr)
                # Save the output
                if not arcpy.Exists(working_dir + "/ScratchDir/StreamLink" + rpu + ".tif"):
                    outStreamLink.save(working_dir + "/ScratchDir/StreamLink" + rpu + ".tif")
                
                # Raster to polyline to get splits along path excatly right
                outStreamLink = Raster(working_dir + "/ScratchDir/StreamLink" + rpu + ".tif")
                outStreamLink = Con(outStreamLink > 0, outStreamLink,)
                if not arcpy.Exists(working_dir + "/ScratchDir/StreamLink" + rpu + ".shp"):
                    arcpy.RasterToPolyline_conversion(in_raster=outStreamLink, out_polyline_features=working_dir + "/ScratchDir/StreamLink" + rpu + ".shp", background_value="NODATA", minimum_dangle_length="0", simplify="NO_SIMPLIFY", raster_field="VALUE")
                
                # Split the polylines at wetland points
                if not arcpy.Exists(working_dir + "/ScratchDir/StreamLinkSplit" + rpu + ".shp"):
                    arcpy.SplitLineAtPoint_management(in_features=working_dir + "/ScratchDir/StreamLink" + rpu + ".shp", point_features = working_dir + "/WetlandPoints" + rpu+ ".shp", out_feature_class = working_dir + "/ScratchDir/StreamLinkSplit" + rpu + ".shp", search_radius="90 Meters")
                
                # Now convert polylines back to a raster
                if not arcpy.Exists(working_dir + "/ScratchDir/StreamLinkSplit.tif"):
                    arcpy.PolylineToRaster_conversion(in_features = working_dir + "/ScratchDir/StreamLinkSplit" + rpu + ".shp", value_field="FID", out_rasterdataset=working_dir + "/ScratchDir/StreamLinkSplit.tif", cell_assignment="MAXIMUM_LENGTH", priority_field="NONE", cellsize="30")
                
                EucAlloc = EucAllocation(working_dir + "/ScratchDir/StreamLinkSplit.tif", "30", "", "30", "Value", "", "")
                
                # Create dummy StreamLink with every value a 1
                PathTemplate = Raster(working_dir + "/ScratchDir/StreamLink" + rpu + ".tif")
                PathTemplate = Con(PathTemplate> 0,1,)
#                    EucAlloc = Raster(temp + '/StreamLink_EucAlloc.tif')
                
                Adjusted = EucAlloc * PathTemplate
                if not arcpy.Exists(working_dir + "/StreamLink" + rpu + ".tif"):  
                    Adjusted.save(working_dir + "/StreamLink" + rpu + ".tif")
                 
```

### Sort out WetlandPathsConnect, WetlandCatsConnect, making final tables
Currently in several scripts that need to be organized here

### Issues to sort out
1. The connection between wetland IDs and wetland paths not totally working.
	a. The split in flow paths happens on the cell downstream of wetland pour points
	b. Because of this, paths that flow through more than one wetland are being assigned
	   to wrong wetland ID in places
	c. The fix is to use the From-To raster to update the wetland-streamlink lookup tables (L:\Priv\CORFiles\Geospatial_Library\Data\Project\WetlandConnectivity\LookupTables)
		i. Wherever there is more than one wetland point associated with a wetland ID in the wetland - streamlink lookup table, then:
			- create a table result of point / raster extracts of wetland points and the From-To .tif
			- If the result of the point extract is NA, keep the streamlink for the wetland in the wetland-streamlink table
			- If the results of the point extract is not NA, replace the streamlink for that wetland with the 'TO' streamlink
2. Slopes for 17b are lower than neighboring regions - why?
3. Need to connect wetland catchments to get full upslope watersheds for precip
4. Calculate geometric mean

## Wetland catchment processes

### Delineate wetland catchments
1. Check to see if catchments already exist
2. If no, run ArcGIS 'watershed' tool on isolated wetlands
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}
# Import arcpy module
import arcpy
import os
from arcpy.sa import *
from arcpy import env
arcpy.CheckOutExtension("spatial")

from datetime import datetime
import struct, decimal, itertools

arcpy.env.overwriteOutput = True

nhddir = 'L:/Priv/CORFiles/Geospatial_Library/Data/RESOURCE/PHYSICAL/HYDROLOGY/NHDPlusV21'
working_dir = 'D:/WorkFolder/WetConnect_Aug2016'
isolated_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/IsolatedWetlands'
watershed_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/WetlandCat/WetCats'

inputs = {'CA':['18'],'CO':['14','15'],'GB':['16'],'GL':['04'],'MA':['02'],'MS':['05','06','07','08','10L','10U','11'],
          'NE':['01'],'PN':['17'],'RG':['13'],'SA':['03N','03S','03W'],'SR':['09'],'TX':['12']}
          
for region in inputs.keys():
    for hydro in inputs[region]:
        print 'Region ' + region + ' and hydro number ' + hydro
        for dirs in os.listdir(nhddir + "/NHDPlus%s/NHDPlus%s"%(region, hydro)):
            if dirs.count("FdrFac") and not dirs.count('.txt') and not dirs.count('.7z'):
                rpu =  dirs[-3:]
                    #Check to see if wetland catchments exist already
                if not os.path.exists(watershed_dir + '/WetlandCat_' + rpu + '.tif'):                     
                    print rpu  
                    startTime = time.time() 
                        #-- Create garbage cans --
                    garbage = working_dir + '/ESRI_garbage/garbage_' + rpu
                    if not os.path.exists(garbage):
                        os.makedirs(garbage)
                    arcpy.env.workspace = garbage
                        #-- Delete garbage after run --
                    startTime = time.time()                      
                    fdr = Raster(nhddir +"/NHDPlus" +region + "/NHDPlus" + hydro + "/NHDPlusFdrFac"  + rpu + "/fdr")
                        # Generate wetland watersheds                      
                    outWtshd = Watershed(fdr, isolated_dir + '/isoWetlands_' + rpu + '.tif', "VALUE")
                        # Save watershed
                    outWtshd.save(watershed_dir + '/WetlandCat_' + rpu + '.tif')                    
                    print "Minutes for this region: " + str((time.time()-startTime) / 60.0)   

```


### Create catchment connections (from-to tables)
1. Shift the catchment in each of the 8 neighboring directions
2. Check each neighboring cell following conditions:
    * Does the cell have a different catchment ID as neighbor?
    * Does it flow into the neighboring cell?
3. If 'yes' to both questions, then connect in topology table
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}

# Import arcpy module
import arcpy
import os
from arcpy.sa import *
from arcpy import env
arcpy.CheckOutExtension("spatial")
from datetime import datetime
import struct, decimal, itertools

arcpy.env.overwriteOutput = True

nhddir = 'L:/Priv/CORFiles/Geospatial_Library/Data/RESOURCE/PHYSICAL/HYDROLOGY/NHDPlusV21'
working_dir = 'D:/WorkFolder/WetConnect_Aug2016'
isolated_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/IsolatedWetlands'
watershed_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/WetlandCat/WetCats'
frmto_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/WetlandCat/FlowTables'

inputs = {'CA':['18'],'CO':['14','15'],'GB':['16'],'GL':['04'],'MA':['02'],'MS':['05','06','07','08','10L','10U','11'],
          'NE':['01'],'PN':['17'],'RG':['13'],'SA':['03N','03S','03W'],'SR':['09'],'TX':['12']}
          
for region in inputs.keys():
    for hydro in inputs[region]:
        print 'Region ' + region + ' and hydro number ' + hydro
        for dirs in os.listdir(nhddir + "/NHDPlus%s/NHDPlus%s"%(region, hydro)):
            if dirs.count("FdrFac") and not dirs.count('.txt') and not dirs.count('.7z'):
                rpu =  dirs[-3:]
                    # Check to see if wetland catchments exist already
                outDbf = frmto_dir + "/WetlandFrmTo" + rpu + ".dbf"
                if not os.path.exists(outDbf):
                        #-- Create garbage cans --
                    garbage = working_dir + '/ESRI_garbage/garbage_' + rpu
                    if not os.path.exists(garbage):
                        os.makedirs(garbage)
                    arcpy.env.workspace = garbage
                        #-- Delete garbage after run --
                    startTime = time.time()   
                    print "Shifting region: " + rpu
                    Wtshds = Raster(watershed_dir + '/WetlandCat_' + rpu + '.tif')     
                    shift1 = arcpy.Shift_management(Wtshds, "shift1.tif", "-30", "0", Wtshds)
                    shift2 = arcpy.Shift_management(Wtshds, "shift2.tif", "-30", "30", Wtshds)
                    shift4 = arcpy.Shift_management(Wtshds, "shift4.tif", "0", "30", Wtshds)
                    shift8 = arcpy.Shift_management(Wtshds, "shift8.tif", "30", "30", Wtshds)
                    shift16 = arcpy.Shift_management(Wtshds, "shift16.tif", "30", "0", Wtshds)
                    shift32 = arcpy.Shift_management(Wtshds, "shift32.tif", "30", "-30", Wtshds)
                    shift64 = arcpy.Shift_management(Wtshds, "shift64.tif", "0", "-30", Wtshds)
                    shift128 = arcpy.Shift_management(Wtshds, "shift128.tif", "-30", "-30", Wtshds)                   
                    print "Minutes to shift this region: " + str((time.time()-startTime) / 60.0) 
                    
                        # Process: Raster Calculator                    
                    print 'Creating from-to connections'
                    startTime = time.time() 
                    fdr = Raster(nhddir +"/NHDPlus" +region + "/NHDPlus" + hydro + "/NHDPlusFdrFac"  + rpu + "/fdr")
                    flowto1 = ((shift1 != Wtshds) * (fdr == 1)) * shift1
                    flowto1.save("FlowTo1.tif")
                    flowto1 = Raster("FlowTo1.tif")
                    flowto1 = Con(IsNull(flowto1),0,flowto1)
                    
                    flowto2 = ((shift2 != Wtshds) * (fdr == 2)) * shift2
                    flowto2.save("FlowTo2.tif")
                    flowto2 = Raster("FlowTo2.tif")
                    flowto2 = Con(IsNull(flowto2),0,flowto2)
                    
                    flowto4 = ((shift4 != Wtshds) * (fdr == 4)) * shift4
                    flowto4.save("FlowTo4.tif")
                    flowto4 = Raster("FlowTo4.tif")
                    flowto4 = Con(IsNull(flowto4),0,flowto4)
                    
                    flowto8 = ((shift8 != Wtshds) * (fdr == 8)) * shift8
                    flowto8.save("FlowTo8.tif")
                    flowto8 = Raster("FlowTo8.tif")
                    flowto8 = Con(IsNull(flowto8),0,flowto8)
                    
                    flowto16 = ((shift16 != Wtshds) * (fdr == 16)) * shift16
                    flowto16.save("FlowTo16.tif")
                    flowto16 = Raster("FlowTo16.tif")
                    flowto16 = Con(IsNull(flowto16),0,flowto16)
                    
                    flowto32 = ((shift32 != Wtshds) * (fdr == 32)) * shift32
                    flowto32.save("FlowTo32.tif")
                    flowto32 = Raster("FlowTo32.tif")
                    flowto32 = Con(IsNull(flowto32),0,flowto32)
                    
                    flowto64 = ((shift64 != Wtshds) * (fdr == 64)) * shift64
                    flowto64.save("FlowTo64.tif")
                    flowto64 = Raster("FlowTo64.tif")
                    flowto64 = Con(IsNull(flowto64),0,flowto64)
                    
                    flowto128 = ((shift128 != Wtshds) * (fdr == 128)) * shift128
                    flowto128.save("FlowTo128.tif")
                    flowto128 = Raster("FlowTo128.tif")
                    flowto128 = Con(IsNull(flowto128),0,flowto128)
                    
                    FlowToSum = flowto1 + flowto2 + flowto4 + flowto8 + flowto16 + flowto32 + flowto64 + flowto128
                    FlowToSum.save("FlowToSum.tif")
                    FlowToSum = Raster("FlowToSum.tif")
                    FlowToFinal = Con(FlowToSum != 0, FlowToSum)
                    FlowToFinal.save("FlowToFinal.tif")
                    
                    outCombine = Combine([FlowToFinal, Wtshds])
                    outCombine.save(working_dir + "/ScratchDir/WetlandFrmTo" + rpu + ".tif")

                    if not arcpy.Exists(outDbf):
                        arcpy.CopyRows_management(outCombine, outDbf, "")
                    print "Minutes to connect catchments in this region: " + str((time.time()-startTime) / 60.0) 
                    
                    try:
                        arcpy.Delete_management("FlowTo1.tif")
                        arcpy.Delete_management("FlowTo2.tif")
                        arcpy.Delete_management("FlowTo4.tif")
                        arcpy.Delete_management("FlowTo8.tif")
                        arcpy.Delete_management("FlowTo16.tif")
                        arcpy.Delete_management("FlowTo32.tif")
                        arcpy.Delete_management("FlowTo64.tif")
                        arcpy.Delete_management("FlowTo128.tif")
                        arcpy.Delete_management("shift1.tif")
                        arcpy.Delete_management("shift2.tif")
                        arcpy.Delete_management("shift4.tif")
                        arcpy.Delete_management("shift8.tif")
                        arcpy.Delete_management("shift16.tif")
                        arcpy.Delete_management("shift32.tif")
                        arcpy.Delete_management("shift64.tif")
                        arcpy.Delete_management("shift128.tif")
                        arcpy.Delete_management("FlowToSum.tif")
                        arcpy.Delete_management("FlowToFinal.tif")
                    except:
                        pass
```


### Create numpy files for accumulating wetland catchment results
1. Loops through from-to tables
2. Makes dictionary of next upstream catchment for each non-headwater catchment
3. Runs children and bastards functions to make full list of upstream catchments
4. Generates information such as length of each connection and saves results as 3 numpy vectors
    * comids<regionID>.npy - Vector of unique IDs for each wetland in region
    * lengths<regionID>.npy - Vector of the number of upstream catchments above each wetland. Children includes focal catchment, bastards excludes focal catchment
    * upCats<regionID>.npy - Vector of the unique IDs of each upstream catchment for each focal catchment listed in order. Focal catchment included for children, excluded for bastards
```{r, engine='python', engine.path='C:/Python27/ArcGIS10.3/python.exe', eval=F}
import arcpy
import os, sys
import pysal as ps
import numpy as np
from collections import deque, defaultdict, OrderedDict

numpy_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/WetlandCat/WetCats_npy/'
frmto_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/WetlandCat/FlowTables/'
watershed_dir = 'L:/Priv/CORFiles/Geospatial_Library/Data/Project/WetlandConnectivity/SpatialDataInputs/Wetlands_NLCD2011/WetlandCat/WetCats/'
    
    #Need to set to where WetCat_function.py is stored
wetcatfunc = 'D:/WorkFolder/WetlandConnectivity/'
sys.path.append(wetcatfunc)  
from WetCat_functions import dbf2DF, children, bastards

files = filter(lambda x: x.endswith(('.dbf')) and not x.count('.tif'), os.listdir(frmto_dir))

for file in files:
    rpu = file[-7:-4]
    print rpu

        #Read in wetland catchments to get list of COMIDs    
    wetcat = watershed_dir + 'WetlandCat_' + rpu + '.tif'
    if not os.path.exists(wetcat + '.vat.dbf'):
        arcpy.BuildRasterAttributeTable_management(wetcat, "Overwrite")
    tbl = dbf2DF(wetcat + '.vat.dbf')
    COMIDs = tbl.VALUE.values      
    
        #Read in from-to table
    flow = dbf2DF(frmto_dir + file)[[1,3]] #Only need columns 1 and 3
    #print flow.head()
    print "Processing region: " + rpu + " with total records = " + str(len(flow))
    flow.columns = ['TOCOMID','FROMCOMID'] #Rename columns
    flow  = flow[flow.FROMCOMID != 0] #Remove paths with FROMCOMID == 0
    fromID = np.array(flow.FROMCOMID) #Make numpy arrays of from and to columns
    toID = np.array(flow.TOCOMID)
    
        #Make dictionary of next up catchment ID
    UpCOMs = defaultdict(list)
    for i in range(0, len(flow), 1):
        FROMID = fromID[i]
        TOID = toID[i]
        UpCOMs[TOID].append(FROMID)                              
        
        #Make and save bastards
    a = map(lambda x: bastards(x, UpCOMs), COMIDs) #Make bastards vector
    lengths = np.array([len(v) for v in a]) #Make lengths vector
    a = np.int32(np.hstack(np.array(a)))    #Convert to 1d vector
    if not os.path.exists(numpy_dir + 'bastards'):
        os.makedirs(numpy_dir + 'bastards')
    np.save(numpy_dir + 'bastards/upCats' + rpu + '.npy', a)
    np.save(numpy_dir + 'bastards/comids' + rpu + '.npy', COMIDs)
    np.save(numpy_dir + 'bastards/lengths' + rpu + '.npy', lengths)
    
         #Make and save children
    a = map(lambda x: children(x, UpCOMs), COMIDs) #Make children vector
    lengths = np.array([len(v) for v in a]) #Make lengths vector
    a = np.int32(np.hstack(np.array(a)))    #Convert to 1d vector
    if not os.path.exists(numpy_dir + 'children'):
        os.makedirs(numpy_dir + 'children')
    np.save(numpy_dir + 'children/upCats' + rpu + '.npy', a)
    np.save(numpy_dir + 'children/comids' + rpu + '.npy', COMIDs)
    np.save(numpy_dir + 'children/lengths' + rpu + '.npy', lengths)   
```

















